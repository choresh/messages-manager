# Messages Manager

## A) General

1) Messages Manager is application which manages messages and provides details about those
messages, specifically whether or not a message is a palindrome. 

2) A message has the following fields:
    * **id**: primary key, generated by the application.
    * **date**: creation date, generated by the application.
    * **type**: the message type (Palindrome/NoPalindrome), calculated by the application.
    * **payload**: a free string, **this is the only field which client should set**.

2) The exposed WEB API:
    * Create message: 
        * Method: POST
        * URL: http://\<host\>:8080/api/messages
        * Body: {"payload": "\<payload\>"}
        * Query params: N.A.
    * Update specific message:
        * Method: PUT
        * URL: http://\<host\>:8080/api/messages/\<message id\>
        * Body: {"payload": "\<payload\>"}
        * Query params: N.A.
    * Delete specific message:
        * Method: DELETE
        * URL: http://\<host\>:8080/api/messages/\<message id\>
        * Body: N.A.
        * Query params: N.A.
    * Retrieve specific message:
        * Method: GET
        * URL: http://\<host\>:8080/api/messages/\<message id\>
        * Body: N.A.
        * Query params: N.A.
    * Retrieve all/some/sorted messages:
        * Method: GET
        * URL: http://\<host\>:8080/api/messages
        * Body: N.A.
        * Query params: 
            * Retrieve all messages, without filtering/sorting:
                * No query params
            * Retrieve all 'Palindrome' messages:
                * ?type=Palindrome
            * Retrieve all 'NoPalindrome' messages:
                * ?type=NoPalindrome
            * Retrieve all messages, sorted by date, in descending order:
                * ?sort=date:desc
            * Retrieve all messages, sorted by date, in ascending order:
                * ?sort=date:asc
            * It is possible to combine the 'type' and 'sort' queries, e.i. any of those 4 combinations is valid:
                * ?type=Palindrome&sort=date:desc
                * ?type=NoPalindrome&sort=date:desc
                * ?type=Palindrome&sort=date:asc
                * ?type=NoPalindrome&sort=date:asc

3) Architecture:
    * The application entry point is class 'src\app.ts', it holds and launch the application's DB and apllication's Server.
    * Below the entry point we have 3 layers:
        * **Api** layer: responsible to receive incomming REST API request, parse the request data (budy/params/query), and call the coresspond code at the lower layer - the **Bl** layer. Its main components are:
            * **Express**: 3rd party, general server framework.
            * **Server**: our thin costomize layer above Express.
            * **Routers**: each of which responsible for routing related to specific resource. Currenly exist only the **Messages Router**. 
        * **BL** layer: responsible for the busness logic. It receivess parsed request from the upper layer (the Api layer), handle the logic, and while need to store/retrive persistent data - call the coresspond code at the lower layer - the **Storage** layer. Its main components are:
            * **Controllers**: each of which responsible for logic of specific resource. Currenly exist only the **Messages Controller**.
            * **Infra**: contains componnets which assists the controllers, currentle exists only the **Messages Processor**, which responsibe for calculation of the message type (yes/no palindrome).
        * **Storage** layer: responsible to store/retrive the persistent data. It receives calls from the upperr layer (the Bl layer). Its main components are:
            * **Type ORM**: 3rd party, general ORM framework, above **Postgres**. It uses the entities classes (i.e. TS schemas) to build the DB's schemas, and privide typed api while need to access the data.
            * **DB**: our thin customize layer above Type ORM.
            * **Entities**: each of which represnt a specific resource. Currenly exist only the **Message**. 
    * More details - see file 'Architecture Diagram.docx' in sub folder 'docs'.

4) In order to achive high performance, **calculation of message type (Palindrome/NoPalindrome) performed at backround**. This mean that while client recive a response for creation or updating of a meeesge - the message type is not calculated yet, i.e. **the calculated value will be inserted to DB a bit later, and in the meantime it will have 'null' value**.
This incomplete state of the message will be reflected in 2 places:
    * At response of the relevant creation/updating operation. Here the 'type' will alwys be 'null'.
    * At response to retrieve message(s), or delete message. Here the 'type' may or may not be 'null'.

5) The application may run in 2 deferent environments:   
    * **Running the application in docker machine (see 'B' below):**
        * Pros:
            * No need to install Postgres on your machine.
            * It validate that resulted dockerized version is OK.    
        * Cons:
            * Uncomfortable for development process (edit/run/debug).
    * **Running the application in local machine (see 'C' below):**
        * Pros:
            * Comfortable for development process (edit/run/debug).     
        * Cons:
            * Need to install Postgres on your machine.
            * It does not validate that resulted dockerized version is OK.

6) Some other notes:
    * Current DB configuration - clearing the DB at each run (see comments, at initialization of 'ConnectionOptions', at file 'src\storage\Infra\db.ts').
    * Non-completed parts of the code marked with 'TODO'.
    
## B) Running the application in **docker machine**

### Prerequisite installations:
* Install Docker engine (e.g. 'Docker Desktop for Windows' - https://hub.docker.com/editions/community/docker-ce-desktop-windows).

### Install, build and run the multi-container Docker applications (Postgres + Messages Manager):
* Go to root folder of the app (the folder where file 'docker-compose.yml' located), and execute the following command:
~~~
docker-compose up --build
~~~
* See the appendix below for some more useful Docker commands.

## C) Running the application in **local machine**

### Prerequisite installations:
* Install NodeJs - https://nodejs.org/en/download.
* Install Postgres - https://www.postgresql.org.

### Create the 'Postgres' database:
* Open the 'pgAdmin' app (part of the 'Postgres' installation).
* Go to: Databases -> right click -> Create -> DataBase, and create new data base with:
    * name: messages-manager.
    * port: 5432.
    * username: postgres.
    * password: postgres.

### Install, build and run the multi-parts local applications (Postgres + Messags Manager):
* Go to root folder of the app (the folder where file 'package.json' located), and execute the following commands sequence:
~~~
npm install
npm run build
npm run start
~~~

## D) Testing the application
* This should done while the application is running (in docker machine (see 'B' above) or in local machine (see 'C' above)).
* Go to root folder of the app (the folder where file 'package.json' located), and execute the following commands sequence (install/build commands - only if not executed yet, they require because they install and build also the testing code):
~~~
npm install
npm run build
npm run test
~~~
* Note: current testing code clears the DB (actually - the Messages table) at each run of the tests.

## E) Appendix

### Other useful Docker commands

#### Build the Messages Manager docker image:
~~~
docker build -t messages.manager .
~~~
#### Run the Messages Manager docker container:
~~~
docker run -it -p 8080:8080 -P messages.manager
~~~
#### Stop all running docker containers:
~~~
docker stop $(docker ps -q)
~~~
#### Remove all docker containers:
~~~
docker rm $(docker ps -a -q)
~~~